name: Prepare Release (Reusable)

on:
  workflow_call:
    inputs:
      version_file_path:
        description: 'Path to the version file (e.g., lib/alchemy/solidus/version.rb)'
        required: true
        type: string
      bump:
        description: 'Version bump type (release, patch, minor, major)'
        required: true
        type: string
    secrets:
      app_id:
        description: 'GitHub App ID for authentication'
        required: true
      app_private_key:
        description: 'GitHub App private key for authentication'
        required: true

jobs:
  prepare:
    runs-on: ubuntu-latest

    steps:
      - name: Generate token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.app_id }}
          private-key: ${{ secrets.app_private_key }}

      - uses: actions/checkout@v4
        with:
          token: ${{ steps.generate-token.outputs.token }}

      - name: Calculate next version
        id: version
        run: |
          # Read current version
          CURRENT=$(grep VERSION ${{ inputs.version_file_path }} | sed 's/.*"\(.*\)".*/\1/')
          echo "Current version: $CURRENT"

          # Strip any pre-release suffix (e.g., .alpha, .beta, .rc1, .a, .b, .c, .dev)
          BASE_VERSION=$(echo "$CURRENT" | sed 's/\.[a-zA-Z][a-zA-Z0-9]*$//')
          echo "Base version: $BASE_VERSION"

          # Split into major.minor.patch
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

          # Bump based on input
          case "${{ inputs.bump }}" in
            release)
              # Just use the base version (strips pre-release suffix)
              ;;
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Configure git
        run: |
          git config user.name "alchemycms-bot"
          git config user.email "alchemycms-bot@users.noreply.github.com"

      - name: Create release branch
        run: |
          git checkout -b release/v${{ steps.version.outputs.version }}

      - name: Generate release notes
        id: release-notes
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const { writeFileSync } = require('fs');

            // Get the previous tag for comparison
            let previousTag;
            try {
              const newVersion = '${{ steps.version.outputs.version }}';
              const [major, minor] = newVersion.split('.');
              const versionPrefix = `v${major}.${minor}.`;

              const tags = await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              const tagNames = tags.data.map(t => t.name);

              // Try same minor series first (e.g., v8.1.x)
              previousTag = tagNames.find(name => name.startsWith(versionPrefix));

              // Fall back to previous minor series (e.g., v8.0.x)
              if (!previousTag && parseInt(minor) > 0) {
                const prevMinorPrefix = `v${major}.${parseInt(minor) - 1}.`;
                previousTag = tagNames.find(name => name.startsWith(prevMinorPrefix));
              }
            } catch (error) {
              console.log('No previous tags found');
            }

            // Generate release notes
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: 'v${{ steps.version.outputs.version }}',
              target_commitish: context.ref.replace('refs/heads/', '')
            };

            if (previousTag) {
              params.previous_tag_name = previousTag;
            }

            const { data } = await github.rest.repos.generateReleaseNotes(params);

            // Save to file for changelog
            writeFileSync('/tmp/release-notes.md', data.body);

            // Also save for PR body
            writeFileSync('/tmp/pr-body.md', data.body);

      - name: Bump version
        run: |
          # Update version file
          sed -i 's/VERSION = "[^"]*"/VERSION = "${{ steps.version.outputs.version }}"/' ${{ inputs.version_file_path }}

          # Update changelog with generated release notes
          DATE=$(date +%Y-%m-%d)
          {
            echo "# Changelog"
            echo ""
            echo "## ${{ steps.version.outputs.version }} ($DATE)"
            echo ""
            cat /tmp/release-notes.md
            echo ""
            tail -n +2 CHANGELOG.md
          } > /tmp/changelog-new.md
          mv /tmp/changelog-new.md CHANGELOG.md

      - name: Commit changes
        run: |
          git add ${{ inputs.version_file_path }} CHANGELOG.md
          git commit -m "Release v${{ steps.version.outputs.version }}"
          git push origin release/v${{ steps.version.outputs.version }}

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          # Build PR body with release notes
          {
            echo "## Release v${{ steps.version.outputs.version }}"
            echo ""
            cat /tmp/pr-body.md
            echo ""
            echo "---"
            echo "This PR was automatically created by the prepare-release workflow."
            echo "Once merged, the gem will be automatically published to RubyGems."
          } > /tmp/full-pr-body.md

          gh pr create \
            --base "$GITHUB_REF_NAME" \
            --head "release/v${{ steps.version.outputs.version }}" \
            --title "Release v${{ steps.version.outputs.version }}" \
            --body-file /tmp/full-pr-body.md \
            --label "skip-changelog"
